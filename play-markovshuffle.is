/// @ 0.19.0
### {
	name: 'マルコフジェネレーター'
	author: 'zawa-ch.'
	description: 'マルコフ連鎖に基づいた文字列の生成'
	version: '1.0.0'
	license: {
		name: "MIT License"
		href: "http://www.opensource.org/licenses/mit-license.php"
	}
}
// markovshuffle.is
// マルコフ連鎖に基づいたランダムオブジェクト列生成
// version 1.0.0
// Copyright 2024 zawa-ch. licensed under MIT License
:: MarkovShuffle {
@make_markov_chain(array) {
	@apply(o, f) { [@(){f(o)}, @(){o}].reduce(@(a,c){c()},null) }
	if Core:type(array) != 'arr' { return Error:create('TYPE_UNMATCH') }
	var cl_n = apply(apply(array.copy(), @(cl_n){ cl_n.shift() }), @(cl_n){ cl_n.push(null) })
	{ first: array.at(0, null), chain: array.map(@(it,ix){ { cur: it, next: cl_n[ix] } }).reduce(@(a,it1){if a.map(@(it2){ it2.item }).incl(it1.cur) { apply(a, @(a){ a[a.map(@(it2){ it2.item }).index_of(it1.cur)].candidates.push(it1.next) }) } else { apply(a, @(a){ a.push({ item: it1.cur, candidates: [ it1.next ] }) }) } }, []).map(@(it1){ apply(it1, @(it1){ it1.candidates = it1.candidates.map(@(it2){ { item: it2, weight: 1 } }).reduce(@(a,it2){ if a.some(@(v){ it2.item == v.item }) { apply(a, @(a) { a[a.map(@(it3){ it3.item }).index_of(it2.item)].weight += 1 }) } else { apply(a, @(a){ a.push(it2) }) } }, []) }) }) }
}
@generate(chain, seed) {
	if Core:type(chain) != 'obj' { return Error:create('TYPE_UNMATCH') }
	if chain.first == null { return null }
	let rand = Math:gen_rng(seed)
	if Core:type(rand) == 'error' { return rand }
	var result = [ chain.first ]
	loop {
		let cc = chain.chain.find(@(it){ it.item == result[0] }).candidates.reduce(@(a,it){ { total: a.total + it.weight, items: a.items.concat([{ item: it.item, begin: a.total, end: a.total + it.weight }]) } }, { total: 0, items: [] })
		let tgt = rand(0, cc.total - 1)
		let next = cc.items.find(@(it){tgt >= it.begin && it.end > tgt})
		if (next.item == null) { break }
		result.unshift(next.item)
	}
	result.reverse()
	result
}
@shuffle_string(string, seed) {
	if Core:type(string) != 'str' { return Error:create('TYPE_UNMATCH') }
	MarkovShuffle:generate(MarkovShuffle:make_markov_chain(string.to_arr()), seed).join()
}
}

@__main() {
	let samples = ['google', 'choo choo train', 'しんぶんし', 'サカバンバスピス', 'ゆりゆららららゆるゆり大事件']
	var gen_text = ''
	var generated = false
	let result_input = Ui:C:text({})
	let result_post_button = Ui:C:postFormButton({ text: "投稿!", primary: true, form: {text: ''} })
	let result = Ui:C:container({ hidden: !generated, children: [ Ui:C:text({ text: '結果', size: 1.2, bold: true }), result_input, result_post_button ]	})
	@generate_and_display() {
		let rt = MarkovShuffle:shuffle_string(gen_text, Util:uuid())
		generated = true
		result_input.update({ text: rt })
		result.update({ hidden: !generated })
		result_post_button.update({ form: { text: [ rt, Str:lf, '<small>Generated by ', if exists THIS_URL {`?[マルコフジェネレーター]({THIS_URL})`} else {'マルコフジェネレーター'}, '</small>' ].join() } })
		buttons.update(buttons_elems())
	}
	@call_sample() {
		input.update({default: samples[Math:rnd(0, samples.len - 1)]})
	}
	@buttons_elems() { { buttons: [
		{ text: '生成!', onClick: generate_and_display, primary: !generated, rounded: false, disabled: gen_text.len <= 0 }
		{ text: 'サンプル', onClick: call_sample, primary: false, rounded: false, disabled: false }
	] }}
	let input = Ui:C:textInput({
		label: '元テキスト',
		caption: '生成するための元となるテキストを入力します。このテキストから文字単位でマルコフ連鎖が構築、文字列が生成されます。',
		default: gen_text,
		onInput: @(v){
			gen_text = v
			buttons.update(buttons_elems())
		}
	})
	let buttons = Ui:C:buttons(buttons_elems())
	Ui:render([input, buttons, result])
}
__main()